//! Smart buffer and related utilities for processing and parsing structured user input.

use crate::edt::EdtCmd;
use crate::key::{DefKeyMap, EscKeyMap, FixKeyMap, KeyMap};
use crate::par::Tkn;
use crossterm::event;
use crossterm::event::Event;
use crossterm::style::{Color, Stylize};
use std::fmt::{Display, Formatter};
use std::io::Result;

/// Escape character.
pub const ESC: char = '\\';

/// Prompt rendered when input is being accepted.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Prompt {
    /// Prompt representing ready for input.
    Ready,
    /// Prompt representing continued input.
    Contd,
}

/// Smart buffer for processing and parsing structured user input.
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Buf {
    /// Raw string backing this buffer.
    pub raw: String,
    /// Index of cursor associated with the raw string.
    pub idx: usize,
    /// Token sequence of grapheme values derived from the raw string.
    pub gfx: Vec<Tkn>,
    /// Represents the state of the buffer being in 'escape mode' which calls for special behavior.
    pub esc: bool,
}

/// Command object that represents possible buffer instructions derived from user input.
#[derive(Clone, Eq, PartialEq)]
pub enum BufCmd {
    /// Perform no operation.
    Noop,
    /// Exit the current read loop.
    Exit,
    /// Set 'escape mode' (which calls for special behavior for the next key pressed).
    Esc(bool),
    /// Perform the given commands in sequence, executing the second only if the first succeeds.
    Compose(Box<BufCmd>, Box<BufCmd>),
    /// Repeat the given command multiple times.
    Repeat(Box<BufCmd>, usize),
    /// Push a character into the buffer (if the buffer isn't full).
    Push(char),
    /// Delete the character immediately **after** the cursor (if there is one).
    Delete,
    /// Clear the buffer.
    Clear,
    /// Move the cursor a row up (if possible).
    MoveUp,
    /// Move the cursor a row down (if possible).
    MoveDn,
    /// Move the cursor a column left (if possible).
    MoveLt,
    /// Move the cursor a column right (if possible).
    MoveRt,
}

/// Result generated by the evaluation of a buffer command.
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct BufRes {
    /// Status of the evaluation of the command.
    pub sts: bool,
    /// Flag that signals termination of the loop.
    pub trm: bool,
}

impl Prompt {
    /// Prefix styled prompts to the given buffer value (even if the value is empty).
    pub fn prefix_to(val: &str) -> String {
        format!(
            "{} {}",
            &Prompt::Ready,
            val.replace('\n', &format!("\r\n{} ", Prompt::Contd))
        )
    }
}

impl Display for Prompt {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Prompt::Ready => write!(f, "{}", "»".with(Color::Cyan)),
            Prompt::Contd => write!(f, "{}", "↳".with(Color::Cyan)),
        }
    }
}

impl Buf {
    /// Create a new instance.
    pub fn new() -> Self {
        Self {
            raw: String::new(),
            idx: 0,
            gfx: vec![],
            esc: false,
        }
    }

    /// Read structured input into a [buffer command][BufCmd] and return it.
    pub fn read(&mut self) -> Result<BufCmd> {
        // TODO: Add more keymaps.
        if let Event::Key(evt) = event::read()? {
            Ok(Option::None
                .or_else(|| EscKeyMap::convert(self, &evt))
                .or_else(|| FixKeyMap::convert(self, &evt))
                .or_else(|| DefKeyMap::convert(self, &evt))
                .unwrap_or(BufCmd::Noop))
        } else {
            Ok(BufCmd::Noop)
        }
    }

    /// Return a displayable string rendering   the contents of the buffer.
    pub fn render(&self) -> String {
        // TODO: Render the sequence with the highest level of meaning.
        // TODO: Render the escape character if in 'escape mode'.
        Prompt::prefix_to(&self.raw)
    }

    /// Return the current parsed value from the buffer.
    pub fn value(&self) -> EdtCmd {
        // TODO: Parse the sequence with the highest level of meaning (or use the existing value if parsing is already done).
        if self.raw.is_empty() {
            EdtCmd::Noop
        } else if self.raw == "exit" || self.raw == "quit" {
            EdtCmd::Exit
        } else {
            EdtCmd::Help(None)
        }
    }
}

impl BufCmd {
    /// Compose this command with another to return a composed command.
    pub fn compose(self, other: BufCmd) -> BufCmd {
        BufCmd::Compose(Box::new(self), Box::new(other))
    }

    /// Create a repeated command.
    pub fn repeat(self, times: usize) -> BufCmd {
        BufCmd::Repeat(Box::new(self), times)
    }

    /// Evaluate the command and return the generated [result][BufRes].
    pub fn eval(self, buf: &mut Buf) -> BufRes {
        match self {
            BufCmd::Noop => BufRes::success(),
            BufCmd::Exit => BufRes::trm(),
            BufCmd::Esc(val) => {
                buf.esc = val;
                BufRes::success()
            }
            BufCmd::Compose(fst, snd) => BufRes::success()
                .and_then(|| fst.eval(buf))
                .and_then(|| snd.eval(buf)),
            BufCmd::Repeat(cmd, cnt) => (0..cnt).fold(BufRes::success(), |acc, _| {
                if acc.sts {
                    let mut ans = cmd.clone().eval(buf);
                    ans.trm = acc.trm; // propagate the terminate flag through the fold
                    ans
                } else {
                    acc // short-circuit if the evaluation failed at any point
                }
            }),
            BufCmd::Push(chr) => {
                if buf.raw.len() < usize::MAX {
                    // Remember the current length of the raw string before updating it.
                    let old_len = buf.raw.len();
                    // Insert the character at the current location.
                    buf.raw.insert(buf.idx, chr);
                    // Increment the index by the same amount that the raw string's length has increased by.
                    buf.idx += buf.raw.len() - old_len;

                    // Update the grapheme sequence since the raw buffer has changed.
                    self.update_gfm(buf);

                    BufRes::success()
                } else {
                    BufRes::failure()
                }
            }
            BufCmd::Delete => {
                if buf.raw.len() > buf.idx {
                    buf.raw.remove(buf.idx);

                    // Update the grapheme sequence since the raw buffer has changed.
                    self.update_gfm(buf);

                    BufRes::success()
                } else {
                    BufRes::failure()
                }
            }
            BufCmd::Clear => {
                *buf = Buf::new();
                BufRes::success()
            }
            BufCmd::MoveUp => todo!(), // TODO: Implement vertical movement.
            BufCmd::MoveDn => todo!(), // TODO: Implement vertical movement.
            BufCmd::MoveLt => todo!(), // TODO: Implement horizontal movement.
            BufCmd::MoveRt => todo!(), // TODO: Implement horizontal movement.
        }
    }

    /// Update the grapheme sequence based on changes to the raw buffer string.
    fn update_gfm(&self, _buf: &mut Buf) {}
}

impl BufRes {
    /// Create a new instance of a success result.
    pub fn success() -> Self {
        Self {
            sts: true,
            trm: false,
        }
    }

    /// Create a new instance of a failure result.
    pub fn failure() -> Self {
        Self {
            sts: false,
            trm: false,
        }
    }

    /// Create a new instance with the 'trm' flag set to true.
    pub fn trm() -> Self {
        Self {
            sts: true,
            trm: true,
        }
    }

    /// If the current result is failure, return it, else apply the function to get a new result.
    pub fn and_then<F: FnOnce() -> BufRes>(self, op: F) -> BufRes {
        if self.sts {
            op()
        } else {
            self
        }
    }
}
