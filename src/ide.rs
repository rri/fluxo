//! Integrated Development Environment (IDE) and associated structures.

use crate::ast::Ctx;
use crate::cmd::{Out, Status};
use crate::edt::Editor;
use crate::pmt::Prompt;
use crossterm::style::{Color, Stylize};
use crossterm::{execute, queue, terminal};
use std::io::{stdout, Result, Write};

/// Integrated Development Environment (IDE) that provides a text-based user interface.
pub struct IDE {
    /// Indicates whether or not the IDE has been initialized (and may hence require cleanup).
    pub init: bool,
}

impl IDE {
    /// Create a new IDE instance.
    pub fn new() -> Self {
        IDE { init: false }
    }

    /// Run the IDE and return a result when the user session ends.
    pub fn run() -> Result<()> {
        let mut ide = Self::new();
        ide.init()?;
        ide.repl()
    }

    /// Perform any initialization operations.
    fn init(&mut self) -> Result<()> {
        self.init = true;
        terminal::enable_raw_mode()?;
        queue!(
            stdout(),
            terminal::EnterAlternateScreen,
            terminal::DisableLineWrap
        )?;
        self.show_banner()
    }

    /// Perform any cleanup operations such as resetting terminal state or restoring buffers.
    fn drop(&self) -> Result<()> {
        execute!(stdout(), terminal::LeaveAlternateScreen)?;
        terminal::disable_raw_mode()
    }

    /// Show a banner with basic information about the application and brief help on navigation.
    fn show_banner(&self) -> Result<()> {
        let mut stdout = stdout();
        write!(
            stdout,
            "{}",
            Prompt::Success.prefix_to(&format!(
                "{} {}\r\n",
                env!("CARGO_PKG_NAME"),
                env!("CARGO_PKG_VERSION")
            ),)
        )?;
        write!(
            stdout,
            "{}",
            Prompt::Diagnostics.prefix_to(&format!(
                "type {} for assistance, {} to exit\r\n",
                "help ↩".with(Color::Red),
                "quit ↩".with(Color::Red),
            ))
        )
    }

    /// Execute a read-eval-print-loop to accept and process user input.
    fn repl(&self) -> Result<()> {
        let ctx = Ctx::new();
        let edt = Editor::new();
        loop {
            let cmd = edt.read()?;
            let out = cmd.eval(&ctx);
            self.emit(&out)?;
            if out.trm {
                return Ok(());
            }
        }
    }

    /// Emit the message generated by the evaluated command, if there is one.
    fn emit(&self, out: &Out) -> Result<()> {
        if let Some(msg) = &out.msg {
            let pmt: &Prompt = From::<&Status>::from(out.status);
            write!(stdout(), "{}", pmt.prefix_to(msg))?;
        }
        Ok(())
    }
}

impl Default for IDE {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for IDE {
    fn drop(&mut self) {
        if self.init {
            if let Err(e) = IDE::drop(self) {
                eprint!("{}", Prompt::Failure.prefix_to("I/O error:"));
                eprint!("{}", Prompt::Diagnostics.prefix_to(&format!("{}", e)));
            }
        }
    }
}
