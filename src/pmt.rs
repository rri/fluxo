//! Styled prompts for various input and output scenarios.

use crossterm::style::{Color, StyledContent, Stylize};
use std::fmt::Display;

use crate::cmd::Status;

/// Types of prompts that may be rendered to the user under various circumstances.
pub enum Prompt {
    /// System is ready for fresh input.
    Ready,
    /// System is ready to resume after previously entered input (which was incomplete).
    Continue,
    /// System has generated the success message that follows the prompt.
    Success,
    /// System has generated the failure message that follows the prompt.
    Failure,
    /// System is providing long-form content (diagnostics, user guide, etc.)
    Content,
}

impl Prompt {
    /// Render success output prefixed with an appropriate prompt.
    pub fn show_success(msg: &str) -> String {
        Self::show_output(msg, |_| &Prompt::Success)
    }

    /// Render failure output prefixed with an appropriate prompt.
    pub fn show_failure(msg: &str) -> String {
        Self::show_output(msg, |i| {
            if i == 0 {
                &Prompt::Failure
            } else {
                &Prompt::Content
            }
        })
    }

    /// Render content output prefixed with an appropriate prompt.
    pub fn show_content(msg: &str) -> String {
        Self::show_output(msg, |_| &Prompt::Content)
    }

    /// Render output prefixed with the prompt generated by the given closure.
    fn show_output<'a>(msg: &str, gen: fn(usize) -> &'a Prompt) -> String {
        msg.lines()
            .enumerate()
            .map(|(i, s)| format!("{} {}\r\n", gen(i), s.trim_end()))
            .collect::<String>()
    }

    /// Render the prompt as styled content (such as a colored string).
    fn as_styled_content(&self) -> StyledContent<&'static str> {
        match self {
            Prompt::Ready => "»".with(Color::Cyan),
            Prompt::Continue => "↳".with(Color::Cyan),
            Prompt::Success => "∴".with(Color::DarkGreen),
            Prompt::Failure => "✗".with(Color::Red),
            Prompt::Content => "≡".with(Color::DarkGrey),
        }
    }
}

impl Default for &Prompt {
    fn default() -> Self {
        &Prompt::Success
    }
}

impl Display for Prompt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_styled_content())
    }
}

impl From<&Status> for &Prompt {
    fn from(status: &Status) -> Self {
        match status {
            Status::Success => &Prompt::Success,
            Status::Failure => &Prompt::Failure,
            Status::Content => &Prompt::Content,
        }
    }
}
