//! Command structures for executing based on user input.

use crate::ast::{Ctx, Exp};
use crate::err::TypingErr;
use crossterm::style::{Color, Stylize};
use unicode_width::UnicodeWidthStr;

/// Command object that represents possible instructions derived from user input.
#[derive(Clone, PartialEq, Eq)]
pub enum Cmd {
    /// Execute the associated [expression][Exp].
    Exec(Exp),
    /// Exit the integrated development environment.
    Exit,
    /// Fail with the associated [typing error][TypingErr].
    Fail(TypingErr),
    /// Show help information.
    Help(Option<Box<Cmd>>),
    /// Perform no operation.
    Noop,
    /// Show the associated [expression][Exp].
    Show(Exp),
    /// Show the type of the associated expression.
    Type(Exp),
}

/// Output object created when a [command][Cmd] is evaluated.
#[derive(Clone, Default)]
pub struct Out<'a> {
    /// Indicator that specifies the nature of the output (through its canonical prompt).
    pub status: &'a Status,
    /// Message generated by the command.
    pub msg: Option<String>,
    /// Flag that signals the parent process to terminate.
    pub trm: bool,
}

/// Disposition of the output generated by [command][Cmd] evaluation.
#[derive(Clone)]
pub enum Status {
    /// Output is generated by successful evaluation of a [command][Cmd].
    Success,
    /// Output is generated by failed evaluation of a [command][Cmd].
    Failure,
    /// Output is neutral and represents a diagnostic message.
    Diagnostics,
}

impl Cmd {
    /// Evaluate this command and return the [output][Out].
    pub fn eval(&self, ctx: &Ctx) -> Out {
        match self {
            Cmd::Noop => Out::new(),
            Cmd::Exit => Out::with_trm(true),
            Cmd::Fail(err) => Out::with_msg(&err.to_string(), &Status::Failure),
            Cmd::Help(tgt) => {
                let mut msg = String::new();
                msg.push_str("COMMAND REFERENCE:\n");
                let commands = vec![
                    Cmd::Help(None),
                    Cmd::Exit,
                    Cmd::Show(Default::default()),
                    Cmd::Type(Default::default()),
                    Cmd::Exec(Default::default()),
                ];
                let targets: Vec<&Cmd> = commands
                    .iter()
                    .filter(|cmd| {
                        if let Some(val) = tgt {
                            **cmd == **val
                        } else {
                            true
                        }
                    })
                    .collect();
                let max = targets
                    .iter()
                    .flat_map(|cmd| cmd.help())
                    .map(|(key, _)| key.width())
                    .max()
                    .unwrap(); // assumes at least one help line
                for cmd in targets {
                    cmd.help().iter().for_each(|(key, val)| {
                        msg.push_str(&format!(
                            "‣ {} {}.... {}\r\n",
                            key.split_once(' ')
                                .map(|(cmd, args)| format!("{} {}", cmd.with(Color::Red), args))
                                .unwrap_or_else(|| format!("{}", key.with(Color::Red))),
                            ".".repeat(max - key.width()),
                            val
                        ))
                    });
                }
                Out::with_msg(&msg, &Status::Diagnostics)
            }
            Cmd::Show(exp) => match exp.clone().reduce(ctx) {
                Ok(exp) => Out::with_msg(&exp.to_string(), &Status::Success),
                Err(e) => Out::with_msg(&e.to_string(), &Status::Failure),
            },
            Cmd::Type(exp) => match exp.calculate_type(ctx) {
                Ok(exp) => Out::with_msg(&exp.to_string(), &Status::Success),
                Err(e) => Out::with_msg(&e.to_string(), &Status::Failure),
            },
            Cmd::Exec(_) => {
                Out::with_msg("Code execution is not yet implemented.", &Status::Failure)
            }
        }
    }

    /// Fetch help information for the command.
    pub fn help(&self) -> Vec<(&'static str, &'static str)> {
        match self {
            Cmd::Fail(_) => vec![], // not invocable by the user, so no user help
            Cmd::Noop => vec![],    // not invocable by the user, so no user help
            Cmd::Help(_) => vec![("help", "Print this help message")],
            Cmd::Exit => vec![
                ("exit", "Exit the integrated development environment"),
                ("quit", "Alias for “exit”"),
            ],
            Cmd::Show(_) => vec![("show EXP", "Show the normalized form of the expression EXP")],
            Cmd::Type(_) => vec![("type EXP", "Show the type of the expression EXP")],
            Cmd::Exec(_) => vec![("exec EXP", "Execute the program denoted by the expression")],
        }
    }
}

impl<'a> Out<'a> {
    /// Create a new instance with reasonable defaults.
    pub fn new() -> Self {
        Self {
            status: &Status::Success,
            msg: None,
            trm: false,
        }
    }

    /// Create a new instance with the given message.
    pub fn with_msg(msg: &str, status: &'a Status) -> Out<'a> {
        let mut res = Self::new();
        res.msg = Some(msg.to_string());
        res.status = status;
        res
    }

    /// Create a new instance with [termination flag][Self::trm] set.
    pub fn with_trm(trm: bool) -> Self {
        let mut res = Self::new();
        res.trm = trm;
        res
    }
}

impl Default for &Status {
    fn default() -> Self {
        &Status::Success
    }
}
